// This file is auto-generated by @hey-api/openapi-ts

import {
  type Options,
  login,
  register,
  logout,
  getAuthMe,
  listAgentInstructions,
  createAgentInstruction,
  deleteAgentInstruction,
  getAgentInstruction,
  updateAgentInstruction,
  listAgentTools,
  addAgentTool,
  removeAgentTool,
  listAgentQueries,
  createAgentQuery,
  deleteAgentQuery,
  getAgentQuery,
  updateAgentQuery,
  ingestAgentDocument,
  listAgentDocuments,
  addAgentDocument,
  deleteAgentDocument,
  getAgentDocument,
  listAgents,
  createAgent,
  deleteAgent,
  getAgent,
  updateAgent,
  listApiTokens,
  createApiToken,
  revokeApiToken,
  listTools,
  createTool,
  deleteTool,
  getTool,
  updateTool,
  listHumanTasks,
  createHumanTask,
  getHumanTaskByQuery,
  deleteHumanTask,
  getHumanTask,
  updateHumanTask,
  resolveHumanTask,
  generateStream,
  updateAgentIndex,
  uploadAndIndex,
  ingestDocument,
  getHealth,
  listAgentStats,
} from "../sdk.gen";
import {
  queryOptions,
  type UseMutationOptions,
  type DefaultError,
  infiniteQueryOptions,
  type InfiniteData,
} from "@tanstack/react-query";
import type {
  LoginData,
  LoginError,
  RegisterData,
  RegisterError,
  LogoutData,
  GetAuthMeData,
  ListAgentInstructionsData,
  ListAgentInstructionsError,
  CreateAgentInstructionData,
  CreateAgentInstructionError,
  DeleteAgentInstructionData,
  DeleteAgentInstructionError,
  DeleteAgentInstructionResponse,
  GetAgentInstructionData,
  UpdateAgentInstructionData,
  UpdateAgentInstructionError,
  ListAgentToolsData,
  ListAgentToolsError,
  AddAgentToolData,
  AddAgentToolError,
  RemoveAgentToolData,
  RemoveAgentToolError,
  RemoveAgentToolResponse,
  ListAgentQueriesData,
  ListAgentQueriesError,
  ListAgentQueriesResponse2,
  CreateAgentQueryData,
  CreateAgentQueryError,
  DeleteAgentQueryData,
  DeleteAgentQueryError,
  DeleteAgentQueryResponse,
  GetAgentQueryData,
  UpdateAgentQueryData,
  UpdateAgentQueryError,
  IngestAgentDocumentData,
  IngestAgentDocumentError,
  ListAgentDocumentsData,
  ListAgentDocumentsError,
  AddAgentDocumentData,
  AddAgentDocumentError,
  DeleteAgentDocumentData,
  DeleteAgentDocumentError,
  DeleteAgentDocumentResponse,
  GetAgentDocumentData,
  ListAgentsData,
  ListAgentsError,
  ListAgentsResponse2,
  CreateAgentData,
  CreateAgentError,
  CreateAgentResponse,
  DeleteAgentData,
  DeleteAgentError,
  DeleteAgentResponse,
  GetAgentData,
  UpdateAgentData,
  UpdateAgentError,
  UpdateAgentResponse,
  ListApiTokensData,
  ListApiTokensError,
  CreateApiTokenData,
  CreateApiTokenError,
  RevokeApiTokenData,
  RevokeApiTokenError,
  RevokeApiTokenResponse,
  ListToolsData,
  ListToolsError,
  CreateToolData,
  CreateToolError,
  DeleteToolData,
  DeleteToolError,
  DeleteToolResponse,
  GetToolData,
  UpdateToolData,
  UpdateToolError,
  ListHumanTasksData,
  ListHumanTasksError,
  ListHumanTasksResponse2,
  CreateHumanTaskData,
  CreateHumanTaskError,
  CreateHumanTaskResponse,
  GetHumanTaskByQueryData,
  DeleteHumanTaskData,
  DeleteHumanTaskError,
  DeleteHumanTaskResponse,
  GetHumanTaskData,
  UpdateHumanTaskData,
  UpdateHumanTaskError,
  UpdateHumanTaskResponse,
  ResolveHumanTaskData,
  ResolveHumanTaskError,
  ResolveHumanTaskResponse,
  GenerateStreamData,
  GenerateStreamError,
  UpdateAgentIndexData,
  UpdateAgentIndexError,
  UpdateAgentIndexResponse2,
  UploadAndIndexData,
  UploadAndIndexError,
  UploadAndIndexResponse2,
  IngestDocumentData,
  IngestDocumentError,
  IngestDocumentResponse,
  GetHealthData,
  ListAgentStatsData,
} from "../types.gen";
import type { AxiosError } from "axios";
import { client as _heyApiClient } from "../client.gen";

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, "baseURL" | "body" | "headers" | "path" | "query"> & {
    _id: string;
    _infinite?: boolean;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseURL: (options?.client ?? _heyApiClient).getConfig().baseURL,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const loginQueryKey = (options: Options<LoginData>) =>
  createQueryKey("login", options);

/**
 * Login
 * Login with email/password; sets session cookie.
 */
export const loginOptions = (options: Options<LoginData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await login({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: loginQueryKey(options),
  });
};

/**
 * Login
 * Login with email/password; sets session cookie.
 */
export const loginMutation = (
  options?: Partial<Options<LoginData>>,
): UseMutationOptions<unknown, AxiosError<LoginError>, Options<LoginData>> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<LoginError>,
    Options<LoginData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await login({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const registerQueryKey = (options: Options<RegisterData>) =>
  createQueryKey("register", options);

/**
 * Register
 * Register a new user and set session cookie.
 */
export const registerOptions = (options: Options<RegisterData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await register({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: registerQueryKey(options),
  });
};

/**
 * Register
 * Register a new user and set session cookie.
 */
export const registerMutation = (
  options?: Partial<Options<RegisterData>>,
): UseMutationOptions<
  unknown,
  AxiosError<RegisterError>,
  Options<RegisterData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<RegisterError>,
    Options<RegisterData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await register({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const logoutQueryKey = (options?: Options<LogoutData>) =>
  createQueryKey("logout", options);

/**
 * Logout
 * Clear session and cookie.
 */
export const logoutOptions = (options?: Options<LogoutData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await logout({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: logoutQueryKey(options),
  });
};

/**
 * Logout
 * Clear session and cookie.
 */
export const logoutMutation = (
  options?: Partial<Options<LogoutData>>,
): UseMutationOptions<
  unknown,
  AxiosError<DefaultError>,
  Options<LogoutData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<DefaultError>,
    Options<LogoutData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await logout({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAuthMeQueryKey = (options?: Options<GetAuthMeData>) =>
  createQueryKey("getAuthMe", options);

/**
 * Current user
 * Return current user (requires cookie or Bearer).
 */
export const getAuthMeOptions = (options?: Options<GetAuthMeData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAuthMe({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAuthMeQueryKey(options),
  });
};

export const listAgentInstructionsQueryKey = (
  options: Options<ListAgentInstructionsData>,
) => createQueryKey("listAgentInstructions", options);

/**
 * List agent instructions
 * Paginated list of instructions for an agent.
 */
export const listAgentInstructionsOptions = (
  options: Options<ListAgentInstructionsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listAgentInstructions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listAgentInstructionsQueryKey(options),
  });
};

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], "body" | "headers" | "path" | "query">,
>(
  queryKey: QueryKey<Options>,
  page: K,
) => {
  const params = {
    ...queryKey[0],
  };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const listAgentInstructionsInfiniteQueryKey = (
  options: Options<ListAgentInstructionsData>,
): QueryKey<Options<ListAgentInstructionsData>> =>
  createQueryKey("listAgentInstructions", options, true);

/**
 * List agent instructions
 * Paginated list of instructions for an agent.
 */
export const listAgentInstructionsInfiniteOptions = (
  options: Options<ListAgentInstructionsData>,
) => {
  return infiniteQueryOptions<
    unknown,
    AxiosError<ListAgentInstructionsError>,
    InfiniteData<unknown>,
    QueryKey<Options<ListAgentInstructionsData>>,
    | number
    | Pick<
        QueryKey<Options<ListAgentInstructionsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListAgentInstructionsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAgentInstructions({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listAgentInstructionsInfiniteQueryKey(options),
    },
  );
};

export const createAgentInstructionQueryKey = (
  options: Options<CreateAgentInstructionData>,
) => createQueryKey("createAgentInstruction", options);

/**
 * Create instruction
 * Add a new instruction to an agent.
 */
export const createAgentInstructionOptions = (
  options: Options<CreateAgentInstructionData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createAgentInstruction({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createAgentInstructionQueryKey(options),
  });
};

/**
 * Create instruction
 * Add a new instruction to an agent.
 */
export const createAgentInstructionMutation = (
  options?: Partial<Options<CreateAgentInstructionData>>,
): UseMutationOptions<
  unknown,
  AxiosError<CreateAgentInstructionError>,
  Options<CreateAgentInstructionData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<CreateAgentInstructionError>,
    Options<CreateAgentInstructionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createAgentInstruction({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete instruction
 * Soft-delete an instruction.
 */
export const deleteAgentInstructionMutation = (
  options?: Partial<Options<DeleteAgentInstructionData>>,
): UseMutationOptions<
  DeleteAgentInstructionResponse,
  AxiosError<DeleteAgentInstructionError>,
  Options<DeleteAgentInstructionData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteAgentInstructionResponse,
    AxiosError<DeleteAgentInstructionError>,
    Options<DeleteAgentInstructionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteAgentInstruction({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAgentInstructionQueryKey = (
  options: Options<GetAgentInstructionData>,
) => createQueryKey("getAgentInstruction", options);

/**
 * Get instruction by ID
 * Return a single instruction for an agent.
 */
export const getAgentInstructionOptions = (
  options: Options<GetAgentInstructionData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAgentInstruction({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAgentInstructionQueryKey(options),
  });
};

/**
 * Update instruction
 * Update content or order of an instruction.
 */
export const updateAgentInstructionMutation = (
  options?: Partial<Options<UpdateAgentInstructionData>>,
): UseMutationOptions<
  unknown,
  AxiosError<UpdateAgentInstructionError>,
  Options<UpdateAgentInstructionData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<UpdateAgentInstructionError>,
    Options<UpdateAgentInstructionData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateAgentInstruction({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listAgentToolsQueryKey = (options: Options<ListAgentToolsData>) =>
  createQueryKey("listAgentTools", options);

/**
 * List agent tools
 * Paginated list of tools linked to an agent.
 */
export const listAgentToolsOptions = (options: Options<ListAgentToolsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listAgentTools({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listAgentToolsQueryKey(options),
  });
};

export const listAgentToolsInfiniteQueryKey = (
  options: Options<ListAgentToolsData>,
): QueryKey<Options<ListAgentToolsData>> =>
  createQueryKey("listAgentTools", options, true);

/**
 * List agent tools
 * Paginated list of tools linked to an agent.
 */
export const listAgentToolsInfiniteOptions = (
  options: Options<ListAgentToolsData>,
) => {
  return infiniteQueryOptions<
    unknown,
    AxiosError<ListAgentToolsError>,
    InfiniteData<unknown>,
    QueryKey<Options<ListAgentToolsData>>,
    | number
    | Pick<
        QueryKey<Options<ListAgentToolsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListAgentToolsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAgentTools({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listAgentToolsInfiniteQueryKey(options),
    },
  );
};

export const addAgentToolQueryKey = (options: Options<AddAgentToolData>) =>
  createQueryKey("addAgentTool", options);

/**
 * Add tool to agent
 * Link a tool to an agent by name (creates tool if missing).
 */
export const addAgentToolOptions = (options: Options<AddAgentToolData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addAgentTool({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addAgentToolQueryKey(options),
  });
};

/**
 * Add tool to agent
 * Link a tool to an agent by name (creates tool if missing).
 */
export const addAgentToolMutation = (
  options?: Partial<Options<AddAgentToolData>>,
): UseMutationOptions<
  unknown,
  AxiosError<AddAgentToolError>,
  Options<AddAgentToolData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<AddAgentToolError>,
    Options<AddAgentToolData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await addAgentTool({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Remove tool from agent
 * Unlink a tool from an agent.
 */
export const removeAgentToolMutation = (
  options?: Partial<Options<RemoveAgentToolData>>,
): UseMutationOptions<
  RemoveAgentToolResponse,
  AxiosError<RemoveAgentToolError>,
  Options<RemoveAgentToolData>
> => {
  const mutationOptions: UseMutationOptions<
    RemoveAgentToolResponse,
    AxiosError<RemoveAgentToolError>,
    Options<RemoveAgentToolData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await removeAgentTool({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listAgentQueriesQueryKey = (
  options: Options<ListAgentQueriesData>,
) => createQueryKey("listAgentQueries", options);

/**
 * List agent queries
 * Paginated list of model queries for an agent.
 */
export const listAgentQueriesOptions = (
  options: Options<ListAgentQueriesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listAgentQueries({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listAgentQueriesQueryKey(options),
  });
};

export const listAgentQueriesInfiniteQueryKey = (
  options: Options<ListAgentQueriesData>,
): QueryKey<Options<ListAgentQueriesData>> =>
  createQueryKey("listAgentQueries", options, true);

/**
 * List agent queries
 * Paginated list of model queries for an agent.
 */
export const listAgentQueriesInfiniteOptions = (
  options: Options<ListAgentQueriesData>,
) => {
  return infiniteQueryOptions<
    ListAgentQueriesResponse2,
    AxiosError<ListAgentQueriesError>,
    InfiniteData<ListAgentQueriesResponse2>,
    QueryKey<Options<ListAgentQueriesData>>,
    | number
    | Pick<
        QueryKey<Options<ListAgentQueriesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListAgentQueriesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAgentQueries({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listAgentQueriesInfiniteQueryKey(options),
    },
  );
};

export const createAgentQueryQueryKey = (
  options: Options<CreateAgentQueryData>,
) => createQueryKey("createAgentQuery", options);

/**
 * Create model query
 * Record a user query and optional model response for an agent.
 */
export const createAgentQueryOptions = (
  options: Options<CreateAgentQueryData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createAgentQuery({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createAgentQueryQueryKey(options),
  });
};

/**
 * Create model query
 * Record a user query and optional model response for an agent.
 */
export const createAgentQueryMutation = (
  options?: Partial<Options<CreateAgentQueryData>>,
): UseMutationOptions<
  unknown,
  AxiosError<CreateAgentQueryError>,
  Options<CreateAgentQueryData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<CreateAgentQueryError>,
    Options<CreateAgentQueryData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createAgentQuery({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete model query
 * Soft-delete a model query.
 */
export const deleteAgentQueryMutation = (
  options?: Partial<Options<DeleteAgentQueryData>>,
): UseMutationOptions<
  DeleteAgentQueryResponse,
  AxiosError<DeleteAgentQueryError>,
  Options<DeleteAgentQueryData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteAgentQueryResponse,
    AxiosError<DeleteAgentQueryError>,
    Options<DeleteAgentQueryData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteAgentQuery({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAgentQueryQueryKey = (options: Options<GetAgentQueryData>) =>
  createQueryKey("getAgentQuery", options);

/**
 * Get query by ID
 * Return a single model query for an agent.
 */
export const getAgentQueryOptions = (options: Options<GetAgentQueryData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAgentQuery({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAgentQueryQueryKey(options),
  });
};

/**
 * Update model query
 * Update user query, model response, or method used.
 */
export const updateAgentQueryMutation = (
  options?: Partial<Options<UpdateAgentQueryData>>,
): UseMutationOptions<
  unknown,
  AxiosError<UpdateAgentQueryError>,
  Options<UpdateAgentQueryData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<UpdateAgentQueryError>,
    Options<UpdateAgentQueryData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateAgentQuery({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ingestAgentDocumentQueryKey = (
  options: Options<IngestAgentDocumentData>,
) => createQueryKey("ingestAgentDocument", options);

/**
 * Ingest document for agent RAG
 * Upload a document (base64); content is chunked and added to the agent's RAG index. When queue is configured, returns 202 with job_id.
 */
export const ingestAgentDocumentOptions = (
  options: Options<IngestAgentDocumentData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ingestAgentDocument({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ingestAgentDocumentQueryKey(options),
  });
};

/**
 * Ingest document for agent RAG
 * Upload a document (base64); content is chunked and added to the agent's RAG index. When queue is configured, returns 202 with job_id.
 */
export const ingestAgentDocumentMutation = (
  options?: Partial<Options<IngestAgentDocumentData>>,
): UseMutationOptions<
  unknown,
  AxiosError<IngestAgentDocumentError>,
  Options<IngestAgentDocumentData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<IngestAgentDocumentError>,
    Options<IngestAgentDocumentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ingestAgentDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listAgentDocumentsQueryKey = (
  options: Options<ListAgentDocumentsData>,
) => createQueryKey("listAgentDocuments", options);

/**
 * List agent documents
 * Paginated list of documents in the agent's RAG index (requires database).
 */
export const listAgentDocumentsOptions = (
  options: Options<ListAgentDocumentsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listAgentDocuments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listAgentDocumentsQueryKey(options),
  });
};

export const listAgentDocumentsInfiniteQueryKey = (
  options: Options<ListAgentDocumentsData>,
): QueryKey<Options<ListAgentDocumentsData>> =>
  createQueryKey("listAgentDocuments", options, true);

/**
 * List agent documents
 * Paginated list of documents in the agent's RAG index (requires database).
 */
export const listAgentDocumentsInfiniteOptions = (
  options: Options<ListAgentDocumentsData>,
) => {
  return infiniteQueryOptions<
    unknown,
    AxiosError<ListAgentDocumentsError>,
    InfiniteData<unknown>,
    QueryKey<Options<ListAgentDocumentsData>>,
    | number
    | Pick<
        QueryKey<Options<ListAgentDocumentsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListAgentDocumentsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAgentDocuments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listAgentDocumentsInfiniteQueryKey(options),
    },
  );
};

export const addAgentDocumentQueryKey = (
  options: Options<AddAgentDocumentData>,
) => createQueryKey("addAgentDocument", options);

/**
 * Add document
 * Add a single document by content (and optional id/metadata). When queue is configured, returns 202 with job_id.
 */
export const addAgentDocumentOptions = (
  options: Options<AddAgentDocumentData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await addAgentDocument({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: addAgentDocumentQueryKey(options),
  });
};

/**
 * Add document
 * Add a single document by content (and optional id/metadata). When queue is configured, returns 202 with job_id.
 */
export const addAgentDocumentMutation = (
  options?: Partial<Options<AddAgentDocumentData>>,
): UseMutationOptions<
  unknown,
  AxiosError<AddAgentDocumentError>,
  Options<AddAgentDocumentData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<AddAgentDocumentError>,
    Options<AddAgentDocumentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await addAgentDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete document
 * Remove a document from the agent's RAG index and DB.
 */
export const deleteAgentDocumentMutation = (
  options?: Partial<Options<DeleteAgentDocumentData>>,
): UseMutationOptions<
  DeleteAgentDocumentResponse,
  AxiosError<DeleteAgentDocumentError>,
  Options<DeleteAgentDocumentData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteAgentDocumentResponse,
    AxiosError<DeleteAgentDocumentError>,
    Options<DeleteAgentDocumentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteAgentDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAgentDocumentQueryKey = (
  options: Options<GetAgentDocumentData>,
) => createQueryKey("getAgentDocument", options);

/**
 * Get document by ID
 * Get a single document by id (UUID or RAG document_id).
 */
export const getAgentDocumentOptions = (
  options: Options<GetAgentDocumentData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAgentDocument({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAgentDocumentQueryKey(options),
  });
};

export const listAgentsQueryKey = (options?: Options<ListAgentsData>) =>
  createQueryKey("listAgents", options);

/**
 * List all agents
 * From DB when configured (optionally by user_id), else from RAG registry. Includes RAG doc count.
 */
export const listAgentsOptions = (options?: Options<ListAgentsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listAgents({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listAgentsQueryKey(options),
  });
};

export const listAgentsInfiniteQueryKey = (
  options?: Options<ListAgentsData>,
): QueryKey<Options<ListAgentsData>> =>
  createQueryKey("listAgents", options, true);

/**
 * List all agents
 * From DB when configured (optionally by user_id), else from RAG registry. Includes RAG doc count.
 */
export const listAgentsInfiniteOptions = (
  options?: Options<ListAgentsData>,
) => {
  return infiniteQueryOptions<
    ListAgentsResponse2,
    AxiosError<ListAgentsError>,
    InfiniteData<ListAgentsResponse2>,
    QueryKey<Options<ListAgentsData>>,
    | number
    | Pick<
        QueryKey<Options<ListAgentsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListAgentsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAgents({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listAgentsInfiniteQueryKey(options),
    },
  );
};

export const createAgentQueryKey = (options: Options<CreateAgentData>) =>
  createQueryKey("createAgent", options);

/**
 * Create a new agent
 * Create agent in DB (and init RAG). Agent ID is always server-generated.
 */
export const createAgentOptions = (options: Options<CreateAgentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createAgent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createAgentQueryKey(options),
  });
};

/**
 * Create a new agent
 * Create agent in DB (and init RAG). Agent ID is always server-generated.
 */
export const createAgentMutation = (
  options?: Partial<Options<CreateAgentData>>,
): UseMutationOptions<
  CreateAgentResponse,
  AxiosError<CreateAgentError>,
  Options<CreateAgentData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAgentResponse,
    AxiosError<CreateAgentError>,
    Options<CreateAgentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createAgent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete agent
 * Soft delete (default) or hard delete. Requires owner.
 */
export const deleteAgentMutation = (
  options?: Partial<Options<DeleteAgentData>>,
): UseMutationOptions<
  DeleteAgentResponse,
  AxiosError<DeleteAgentError>,
  Options<DeleteAgentData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteAgentResponse,
    AxiosError<DeleteAgentError>,
    Options<DeleteAgentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteAgent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAgentQueryKey = (options: Options<GetAgentData>) =>
  createQueryKey("getAgent", options);

/**
 * Get agent by ID
 * Get agent by id (from DB when configured).
 */
export const getAgentOptions = (options: Options<GetAgentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAgent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAgentQueryKey(options),
  });
};

/**
 * Update agent by ID
 * Update name, mode, prompt, instructions, or tools.
 */
export const updateAgentMutation = (
  options?: Partial<Options<UpdateAgentData>>,
): UseMutationOptions<
  UpdateAgentResponse,
  AxiosError<UpdateAgentError>,
  Options<UpdateAgentData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateAgentResponse,
    AxiosError<UpdateAgentError>,
    Options<UpdateAgentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateAgent({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listApiTokensQueryKey = (options?: Options<ListApiTokensData>) =>
  createQueryKey("listApiTokens", options);

/**
 * List API tokens
 * List current user's API tokens (token values are never returned).
 */
export const listApiTokensOptions = (options?: Options<ListApiTokensData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listApiTokens({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listApiTokensQueryKey(options),
  });
};

export const listApiTokensInfiniteQueryKey = (
  options?: Options<ListApiTokensData>,
): QueryKey<Options<ListApiTokensData>> =>
  createQueryKey("listApiTokens", options, true);

/**
 * List API tokens
 * List current user's API tokens (token values are never returned).
 */
export const listApiTokensInfiniteOptions = (
  options?: Options<ListApiTokensData>,
) => {
  return infiniteQueryOptions<
    unknown,
    AxiosError<ListApiTokensError>,
    InfiniteData<unknown>,
    QueryKey<Options<ListApiTokensData>>,
    | number
    | Pick<
        QueryKey<Options<ListApiTokensData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListApiTokensData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listApiTokens({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listApiTokensInfiniteQueryKey(options),
    },
  );
};

export const createApiTokenQueryKey = (options: Options<CreateApiTokenData>) =>
  createQueryKey("createApiToken", options);

/**
 * Create API token
 * Create an API token. The plain token is returned only in this response.
 */
export const createApiTokenOptions = (options: Options<CreateApiTokenData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createApiToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createApiTokenQueryKey(options),
  });
};

/**
 * Create API token
 * Create an API token. The plain token is returned only in this response.
 */
export const createApiTokenMutation = (
  options?: Partial<Options<CreateApiTokenData>>,
): UseMutationOptions<
  unknown,
  AxiosError<CreateApiTokenError>,
  Options<CreateApiTokenData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<CreateApiTokenError>,
    Options<CreateApiTokenData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createApiToken({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Revoke API token
 * Revoke an API token by ID.
 */
export const revokeApiTokenMutation = (
  options?: Partial<Options<RevokeApiTokenData>>,
): UseMutationOptions<
  RevokeApiTokenResponse,
  AxiosError<RevokeApiTokenError>,
  Options<RevokeApiTokenData>
> => {
  const mutationOptions: UseMutationOptions<
    RevokeApiTokenResponse,
    AxiosError<RevokeApiTokenError>,
    Options<RevokeApiTokenData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await revokeApiToken({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listToolsQueryKey = (options?: Options<ListToolsData>) =>
  createQueryKey("listTools", options);

/**
 * List tools
 * Paginated list of all tools in the registry.
 */
export const listToolsOptions = (options?: Options<ListToolsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listTools({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listToolsQueryKey(options),
  });
};

export const listToolsInfiniteQueryKey = (
  options?: Options<ListToolsData>,
): QueryKey<Options<ListToolsData>> =>
  createQueryKey("listTools", options, true);

/**
 * List tools
 * Paginated list of all tools in the registry.
 */
export const listToolsInfiniteOptions = (options?: Options<ListToolsData>) => {
  return infiniteQueryOptions<
    unknown,
    AxiosError<ListToolsError>,
    InfiniteData<unknown>,
    QueryKey<Options<ListToolsData>>,
    | number
    | Pick<
        QueryKey<Options<ListToolsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListToolsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listTools({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listToolsInfiniteQueryKey(options),
    },
  );
};

export const createToolQueryKey = (options: Options<CreateToolData>) =>
  createQueryKey("createTool", options);

/**
 * Create tool
 * Create a new tool in the registry by name.
 */
export const createToolOptions = (options: Options<CreateToolData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createTool({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createToolQueryKey(options),
  });
};

/**
 * Create tool
 * Create a new tool in the registry by name.
 */
export const createToolMutation = (
  options?: Partial<Options<CreateToolData>>,
): UseMutationOptions<
  unknown,
  AxiosError<CreateToolError>,
  Options<CreateToolData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<CreateToolError>,
    Options<CreateToolData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createTool({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete tool
 * Soft delete (default) or hard delete a tool.
 */
export const deleteToolMutation = (
  options?: Partial<Options<DeleteToolData>>,
): UseMutationOptions<
  DeleteToolResponse,
  AxiosError<DeleteToolError>,
  Options<DeleteToolData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteToolResponse,
    AxiosError<DeleteToolError>,
    Options<DeleteToolData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteTool({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getToolQueryKey = (options: Options<GetToolData>) =>
  createQueryKey("getTool", options);

/**
 * Get tool by ID
 * Return a single tool by ID.
 */
export const getToolOptions = (options: Options<GetToolData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTool({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getToolQueryKey(options),
  });
};

/**
 * Update tool
 * Update tool name by ID.
 */
export const updateToolMutation = (
  options?: Partial<Options<UpdateToolData>>,
): UseMutationOptions<
  unknown,
  AxiosError<UpdateToolError>,
  Options<UpdateToolData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<UpdateToolError>,
    Options<UpdateToolData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateTool({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listHumanTasksQueryKey = (options?: Options<ListHumanTasksData>) =>
  createQueryKey("listHumanTasks", options);

/**
 * List human tasks
 * Paginated list of human-in-the-loop tasks; optional filter by PENDING.
 */
export const listHumanTasksOptions = (
  options?: Options<ListHumanTasksData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listHumanTasks({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listHumanTasksQueryKey(options),
  });
};

export const listHumanTasksInfiniteQueryKey = (
  options?: Options<ListHumanTasksData>,
): QueryKey<Options<ListHumanTasksData>> =>
  createQueryKey("listHumanTasks", options, true);

/**
 * List human tasks
 * Paginated list of human-in-the-loop tasks; optional filter by PENDING.
 */
export const listHumanTasksInfiniteOptions = (
  options?: Options<ListHumanTasksData>,
) => {
  return infiniteQueryOptions<
    ListHumanTasksResponse2,
    AxiosError<ListHumanTasksError>,
    InfiniteData<ListHumanTasksResponse2>,
    QueryKey<Options<ListHumanTasksData>>,
    | number
    | Pick<
        QueryKey<Options<ListHumanTasksData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListHumanTasksData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listHumanTasks({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listHumanTasksInfiniteQueryKey(options),
    },
  );
};

export const createHumanTaskQueryKey = (
  options: Options<CreateHumanTaskData>,
) => createQueryKey("createHumanTask", options);

/**
 * Create human task
 * Create a human-in-the-loop task for a model query.
 */
export const createHumanTaskOptions = (
  options: Options<CreateHumanTaskData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createHumanTask({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: createHumanTaskQueryKey(options),
  });
};

/**
 * Create human task
 * Create a human-in-the-loop task for a model query.
 */
export const createHumanTaskMutation = (
  options?: Partial<Options<CreateHumanTaskData>>,
): UseMutationOptions<
  CreateHumanTaskResponse,
  AxiosError<CreateHumanTaskError>,
  Options<CreateHumanTaskData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateHumanTaskResponse,
    AxiosError<CreateHumanTaskError>,
    Options<CreateHumanTaskData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await createHumanTask({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getHumanTaskByQueryQueryKey = (
  options: Options<GetHumanTaskByQueryData>,
) => createQueryKey("getHumanTaskByQuery", options);

/**
 * Get task by model query ID
 * Return the human task linked to a model query.
 */
export const getHumanTaskByQueryOptions = (
  options: Options<GetHumanTaskByQueryData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getHumanTaskByQuery({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getHumanTaskByQueryQueryKey(options),
  });
};

/**
 * Delete human task
 * Delete a human task by ID.
 */
export const deleteHumanTaskMutation = (
  options?: Partial<Options<DeleteHumanTaskData>>,
): UseMutationOptions<
  DeleteHumanTaskResponse,
  AxiosError<DeleteHumanTaskError>,
  Options<DeleteHumanTaskData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteHumanTaskResponse,
    AxiosError<DeleteHumanTaskError>,
    Options<DeleteHumanTaskData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await deleteHumanTask({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getHumanTaskQueryKey = (options: Options<GetHumanTaskData>) =>
  createQueryKey("getHumanTask", options);

/**
 * Get human task by ID
 * Return a single human task by ID.
 */
export const getHumanTaskOptions = (options: Options<GetHumanTaskData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getHumanTask({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getHumanTaskQueryKey(options),
  });
};

/**
 * Update human task
 * Update reason, retrieved data, model message, or status.
 */
export const updateHumanTaskMutation = (
  options?: Partial<Options<UpdateHumanTaskData>>,
): UseMutationOptions<
  UpdateHumanTaskResponse,
  AxiosError<UpdateHumanTaskError>,
  Options<UpdateHumanTaskData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateHumanTaskResponse,
    AxiosError<UpdateHumanTaskError>,
    Options<UpdateHumanTaskData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateHumanTask({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const resolveHumanTaskQueryKey = (
  options: Options<ResolveHumanTaskData>,
) => createQueryKey("resolveHumanTask", options);

/**
 * Resolve human task
 * Mark a human task as resolved.
 */
export const resolveHumanTaskOptions = (
  options: Options<ResolveHumanTaskData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await resolveHumanTask({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: resolveHumanTaskQueryKey(options),
  });
};

/**
 * Resolve human task
 * Mark a human task as resolved.
 */
export const resolveHumanTaskMutation = (
  options?: Partial<Options<ResolveHumanTaskData>>,
): UseMutationOptions<
  ResolveHumanTaskResponse,
  AxiosError<ResolveHumanTaskError>,
  Options<ResolveHumanTaskData>
> => {
  const mutationOptions: UseMutationOptions<
    ResolveHumanTaskResponse,
    AxiosError<ResolveHumanTaskError>,
    Options<ResolveHumanTaskData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await resolveHumanTask({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const generateStreamQueryKey = (options: Options<GenerateStreamData>) =>
  createQueryKey("generateStream", options);

/**
 * Stream chat (router + generator)
 * Call #1: cheap router decides needs_rag, tools_needed, model_to_use. Call #2: dynamic generator streams the response. Returns NDJSON: router_decision, then text chunks, then final metrics.
 */
export const generateStreamOptions = (options: Options<GenerateStreamData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await generateStream({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: generateStreamQueryKey(options),
  });
};

/**
 * Stream chat (router + generator)
 * Call #1: cheap router decides needs_rag, tools_needed, model_to_use. Call #2: dynamic generator streams the response. Returns NDJSON: router_decision, then text chunks, then final metrics.
 */
export const generateStreamMutation = (
  options?: Partial<Options<GenerateStreamData>>,
): UseMutationOptions<
  unknown,
  AxiosError<GenerateStreamError>,
  Options<GenerateStreamData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AxiosError<GenerateStreamError>,
    Options<GenerateStreamData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await generateStream({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const updateAgentIndexQueryKey = (
  options: Options<UpdateAgentIndexData>,
) => createQueryKey("updateAgentIndex", options);

/**
 * Update RAG index
 * Add, update, or delete a document in the agent's index. Actions: add, update (need content JSON), delete (need doc_id).
 */
export const updateAgentIndexOptions = (
  options: Options<UpdateAgentIndexData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await updateAgentIndex({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: updateAgentIndexQueryKey(options),
  });
};

/**
 * Update RAG index
 * Add, update, or delete a document in the agent's index. Actions: add, update (need content JSON), delete (need doc_id).
 */
export const updateAgentIndexMutation = (
  options?: Partial<Options<UpdateAgentIndexData>>,
): UseMutationOptions<
  UpdateAgentIndexResponse2,
  AxiosError<UpdateAgentIndexError>,
  Options<UpdateAgentIndexData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateAgentIndexResponse2,
    AxiosError<UpdateAgentIndexError>,
    Options<UpdateAgentIndexData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await updateAgentIndex({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadAndIndexQueryKey = (options: Options<UploadAndIndexData>) =>
  createQueryKey("uploadAndIndex", options);

/**
 * Upload JSONL and index
 * Upload JSONL (one JSON per line: id, content, optional metadata) and index into the agent's RAG.
 */
export const uploadAndIndexOptions = (options: Options<UploadAndIndexData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadAndIndex({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadAndIndexQueryKey(options),
  });
};

/**
 * Upload JSONL and index
 * Upload JSONL (one JSON per line: id, content, optional metadata) and index into the agent's RAG.
 */
export const uploadAndIndexMutation = (
  options?: Partial<Options<UploadAndIndexData>>,
): UseMutationOptions<
  UploadAndIndexResponse2,
  AxiosError<UploadAndIndexError>,
  Options<UploadAndIndexData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadAndIndexResponse2,
    AxiosError<UploadAndIndexError>,
    Options<UploadAndIndexData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await uploadAndIndex({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ingestDocumentQueryKey = (options: Options<IngestDocumentData>) =>
  createQueryKey("ingestDocument", options);

/**
 * Ingest document (PDF, TXT, DOCX)
 * Upload PDF, TXT, or DOCX; content is extracted, chunked, embedded, and added to the agent's RAG.
 */
export const ingestDocumentOptions = (options: Options<IngestDocumentData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ingestDocument({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ingestDocumentQueryKey(options),
  });
};

/**
 * Ingest document (PDF, TXT, DOCX)
 * Upload PDF, TXT, or DOCX; content is extracted, chunked, embedded, and added to the agent's RAG.
 */
export const ingestDocumentMutation = (
  options?: Partial<Options<IngestDocumentData>>,
): UseMutationOptions<
  IngestDocumentResponse,
  AxiosError<IngestDocumentError>,
  Options<IngestDocumentData>
> => {
  const mutationOptions: UseMutationOptions<
    IngestDocumentResponse,
    AxiosError<IngestDocumentError>,
    Options<IngestDocumentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ingestDocument({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getHealthQueryKey = (options?: Options<GetHealthData>) =>
  createQueryKey("getHealth", options);

/**
 * Health check
 * Returns status, agents with RAG, GeminiMesh flag, embedding backend, and DB status.
 */
export const getHealthOptions = (options?: Options<GetHealthData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getHealth({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getHealthQueryKey(options),
  });
};

export const listAgentStatsQueryKey = (options: Options<ListAgentStatsData>) =>
  createQueryKey("listAgentStats", options);

/**
 * List agent daily stats
 * Daily aggregates of model queries for this agent (totalQueries per day). Optional days=30.
 */
export const listAgentStatsOptions = (options: Options<ListAgentStatsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listAgentStats({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listAgentStatsQueryKey(options),
  });
};
